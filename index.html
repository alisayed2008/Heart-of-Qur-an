<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>خريطة حفظ القرآن — القلب</title>
<link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg: #ffffff;
    --accent: #ff4d4d;
    --accent-strong: #e60000;
    --muted: #6b7280;
    --shadow: 0 12px 40px rgba(2,6,23,0.08);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:'El Messiri',sans-serif;background:var(--bg);color:#071133}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px;}
  .panel{width:100%;max-width:1100px;border-radius:16px;background:linear-gradient(180deg,#fff,#fcfdff);box-shadow:var(--shadow);display:flex;gap:20px;padding:20px;}
  .card{flex:0 0 680px;padding:18px;border-radius:12px;background:linear-gradient(180deg,#ffffff,#fbfdff);border:1px solid #eef4fb}
  .card-header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .title{font-size:18px;font-weight:700}
  .sub{color:var(--muted);font-size:13px}
  .heart-container{background:linear-gradient(180deg,#fff,#f7fbff);padding:16px;border-radius:12px;border:1px solid #eef6fc;display:flex;align-items:center;justify-content:center;min-height:420px}
  svg{max-width:100%;height:auto;display:block}

  /* ---------- التعديل الأساسي: الحدود السوداء دايمًا + التلوين فقط عند revealed ---------- */
  .segment{
    fill: transparent !important;      /* مفرغ من البداية */
    stroke: #000 !important;           /* حدود سوداء ظاهرة من البداية */
    stroke-width: 1.6 !important;
    cursor: pointer;
    transition: transform .18s ease, filter .18s ease, fill .25s ease;
  }
  .segment:hover{transform:translateY(-4px);filter:drop-shadow(0 10px 20px rgba(3,7,18,0.06))}
  .segment.revealed{
    fill: var(--accent) !important;    /* أحمر فقط عند الحفظ */
    stroke: #000 !important;           /* حدود تظل سوداء */
  }

  /* animation class kept for compatibility but it no longer toggles stroke color */
  .segment.anim-stroke{
    /* kept empty or minor styling; drawing is done via overlay element in JS */
  }

  /* overlay draw path style (temporary red stroke drawn on top of segment but under outlines) */
  .overlay-draw{
    pointer-events:none;
    fill:none;
    stroke: #ff4d4d;
    stroke-width: 2.6;
    stroke-linecap:round;
    stroke-linejoin:round;
  }

  /* outlines & labels (injected on top of shapes) */
  .outline{fill:none;stroke:#000;stroke-width:1.8;pointer-events:none}
  svg text.segment-label{font-size:10px;font-weight:600;fill:#071133;pointer-events:none;text-anchor:middle;dominant-baseline:central;font-family:'El Messiri',sans-serif}
  svg text.segment-label.revealed{fill:#ffffff}

  /* sidebar */
  .sidebar{flex:1;min-width:260px;display:flex;flex-direction:column;gap:12px}
  .panel-block{background:#fff;padding:12px;border-radius:10px;border:1px solid #f0f6fb;box-shadow:0 6px 18px rgba(12,15,35,0.03)}
  .progress-bar{height:12px;background:#eef6fb;border-radius:8px;overflow:hidden}
  .progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-strong));width:0%;transition:width .6s ease}
  .big-num{font-weight:700;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center;justify-content:flex-end}
  button.btn{background:var(--accent);color:white;padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700;box-shadow:0 8px 20px rgba(255,77,77,0.14)}
  button.ghost{background:transparent;border:1px solid #e6eef7;color:var(--muted);padding:8px 12px;border-radius:10px;cursor:pointer}

  .modal-backdrop{position:fixed;inset:0;background:rgba(2,6,23,0.45);display:none;align-items:center;justify-content:center;z-index:60}
  .modal{background:white;padding:18px;border-radius:12px;min-width:320px;box-shadow:0 18px 60px rgba(2,6,23,0.25)}
  .modal h3{margin:0 0 8px}
  .modal p{margin:0 0 14px;color:var(--muted)}
  .modal .row{display:flex;gap:10px;justify-content:flex-end}

  footer.note{font-size:13px;color:var(--muted);margin-top:8px}
  @media (max-width:980px){.panel{flex-direction:column}.card{width:100%}}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="card">
      <div class="card-header">
        <div>
          <div class="title">خريطة حفظ القرآن — القلب</div>
          <div class="sub">اضغط أي جزء لتأكيد الحفظ. التقدم يُخزّن على جهازك.</div>
        </div>
        <div class="controls">
          <button class="ghost" id="btn-list" title="عرض السور المحفوظة">قائمة</button>
          <button class="btn" id="btn-reset" title="إعادة التقدم">إعادة</button>
        </div>
      </div>

      <div class="heart-container" id="heart-wrap">
        <div id="svg-loader" class="muted">جارٍ تحميل القلب…</div>
      </div>

      <footer class="note">لو احتجت أغير حجم الخط داخل التقسيمات أو أظهر أسماء السور بشكل أكبر/أصغر أخبرني.</footer>
    </div>

    <aside class="sidebar">
      <div class="panel-block">
        <div class="muted">التقدم</div>
        <div style="display:flex;align-items:center;justify-content:space-between;margin-top:8px">
          <div class="big-num" id="count-text">0 / 0</div>
          <div class="muted" id="last-text">لا شيء محفوظ</div>
        </div>
        <div style="margin-top:12px" class="progress-bar">
          <div id="progress-fill" class="progress-fill"></div>
        </div>
      </div>

      <div class="panel-block">
        <div class="muted">رسائل تشجيع</div>
        <div style="margin-top:10px;font-weight:600" id="encourage">ابدأ اليوم — خطوة خطوة 🌿</div>
      </div>

      <div class="panel-block">
        <div class="muted">ملاحظات</div>
        <ul style="margin:10px 0 0 18px;color:var(--muted);font-size:14px">
          <li>القلب بالحدود السوداء كما طلبت.</li>
          <li>الأسماء داخل كل تقسيمة مرئية الآن.</li>
          <li>الخطوط الفاصلة تبقى مرئية حتى بعد التلوين.</li>
        </ul>
      </div>
    </aside>
  </div>
</div>

<!-- Modal Confirm -->
<div id="modal" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog">
    <h3 id="modal-title">تأكيد إتمام الحفظ</h3>
    <p id="modal-body">هل أنت متأكد من إتمام حفظ سورة ...؟</p>
    <div class="row">
      <button class="ghost" id="modal-cancel">إلغاء</button>
      <button class="btn" id="modal-confirm">متأكد</button>
    </div>
  </div>
</div>

<script>
const SVG_FILE = 'heart_segments_named.svg'; // تأكد اسم ملف الـSVG هنا

// DOM refs
const heartWrap = document.getElementById('heart-wrap');
const loader = document.getElementById('svg-loader');
const modalEl = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalBody = document.getElementById('modal-body');
const modalCancel = document.getElementById('modal-cancel');
const modalConfirm = document.getElementById('modal-confirm');
const progressFill = document.getElementById('progress-fill');
const countText = document.getElementById('count-text');
const lastText = document.getElementById('last-text');
const encourage = document.getElementById('encourage');
const btnReset = document.getElementById('btn-reset');
const btnList = document.getElementById('btn-list');

let segments = [];
let saved = JSON.parse(localStorage.getItem('quran_heart_progress') || '{}') || {};
if (!saved || typeof saved !== 'object') saved = {};

// load SVG and inject inline
async function loadAndInjectSVG(){
  try{
    const res = await fetch(SVG_FILE);
    if(!res.ok) throw new Error('SVG not found: ' + res.status);
    const text = await res.text();
    heartWrap.innerHTML = text;
    segments = Array.from(heartWrap.querySelectorAll('.segment'));
    loader && loader.remove();
    initializeSegments();
    // create outlines and labels on top
    const svgRoot = heartWrap.querySelector('svg');
    if(svgRoot) setTimeout(()=>createOutlinesAndLabels(svgRoot), 120);
    updateUI();
  } catch(err){
    console.error(err);
    if(loader) loader.innerText = 'خطأ في تحميل الملف: ' + err.message;
  }
}

function updateUI(){
  const total = segments.length;
  const done = Object.keys(saved).filter(k => k !== '_last').length;
  countText.textContent = `${done} / ${total}`;
  lastText.textContent = saved._last ? `آخر: ${saved._last}` : 'لا شيء محفوظ';
  progressFill.style.width = total ? `${Math.round((done/total)*100)}%` : '0%';
}

function initializeSegments(){
  if(!segments.length){
    heartWrap.querySelector('#svg-loader')?.remove();
    heartWrap.insertAdjacentHTML('beforeend','<div class="muted">لا يوجد مقاطع (segments) في الـSVG</div>');
    return;
  }

  segments.forEach(seg=>{
    const name = seg.getAttribute('data-name') || seg.getAttribute('id') || 'غير معروف';

    // force stroke & empty fill from the start (we don't change structure)
    seg.setAttribute('fill', 'transparent');
    seg.setAttribute('stroke', seg.getAttribute('stroke') || '#000');
    seg.style.cursor = 'pointer';

    if(saved[name]){
      seg.classList.add('revealed');
    }

    try{
      const len = seg.getTotalLength();
      seg.style.strokeDasharray = len;
      seg.style.strokeDashoffset = len;
      seg.dataset._len = len;
    } catch(e){}

    seg.addEventListener('click', (e)=>{
      e.preventDefault();
      if(saved[name]) {
        encourage.textContent = `لقد سبق حفظ "${name}".`;
        return;
      }
      modalTitle.textContent = 'تأكيد إتمام الحفظ';
      modalBody.textContent = `هل أنت متأكد من إتمام حفظ سورة "${name}"؟`;
      modalEl.style.display = 'flex';
      modalEl.dataset.target = name;
    });
  });
}

/* --- outlines and labels: generate top outlines and centered labels for segments --- */
function createOutlinesAndLabels(svgRoot){
  try{
    const existingOut = svgRoot.querySelector('#__outlines_group');
    if(existingOut) existingOut.remove();
    const outlinesG = document.createElementNS('http://www.w3.org/2000/svg','g');
    outlinesG.setAttribute('id','__outlines_group');
    const labelsG = document.createElementNS('http://www.w3.org/2000/svg','g');
    labelsG.setAttribute('id','__labels_group');

    segments.forEach(seg=>{
      try{
        // outline clone (drawn on top)
        const clone = seg.cloneNode(false);
        clone.classList.remove('segment');
        clone.classList.add('outline');
        clone.setAttribute('fill','none');
        clone.setAttribute('stroke','#000');
        clone.setAttribute('stroke-width','1.8');
        clone.style.pointerEvents = 'none';
        outlinesG.appendChild(clone);

        // label
        const name = seg.getAttribute('data-name') || seg.getAttribute('id') || '';
        let cx = 0, cy = 0;
        let bb = null;
        try{ bb = seg.getBBox(); cx = bb.x + bb.width/2; cy = bb.y + bb.height/2; } catch(e){
          const sbb = svgRoot.getBBox(); cx = sbb.width/2; cy = sbb.height/2;
        }
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('class','segment-label');
        txt.setAttribute('x',cx);
        txt.setAttribute('y',cy);
        txt.textContent = name;
        try{ const size = Math.max(8, Math.min(14, Math.round(Math.min(bb.width, bb.height) * 0.18))); txt.style.fontSize = size + 'px'; }catch(e){}
        labelsG.appendChild(txt);
      }catch(err){
        console.warn('outline/label err',err);
      }
    });

    // append outlines and labels at the end so they are drawn on top
    svgRoot.appendChild(outlinesG);
    svgRoot.appendChild(labelsG);

    // apply revealed class to corresponding labels
    segments.forEach((s,i)=>{
      const name = s.getAttribute('data-name') || s.getAttribute('id') || '';
      const label = labelsG.children[i];
      if(!label) return;
      if(saved[name]) label.classList.add('revealed');
    });

  }catch(e){ console.warn('createOutlinesAndLabels failed',e); }
}
/* --- end outlines/labels --- */

function animateDrawThenReveal(seg, name, onDone){
  // create overlay path clone to draw red stroke, then remove it and reveal original segment
  const svgRoot = heartWrap.querySelector('svg');
  if(!svgRoot){
    // fallback: directly reveal
    seg.classList.add('revealed');
    if(typeof onDone === 'function') onDone();
    return;
  }
  try{
    const overlay = seg.cloneNode(false);
    overlay.classList.add('overlay-draw');
    overlay.setAttribute('fill','none');
    overlay.setAttribute('stroke','#ff4d4d');
    overlay.setAttribute('stroke-width','2.6');
    // compute length and set dash
    let len = 0;
    try{ len = overlay.getTotalLength(); } catch(e){ len = seg.dataset._len || 0; }
    overlay.style.strokeDasharray = len;
    overlay.style.strokeDashoffset = len;
    overlay.style.transition = 'stroke-dashoffset 0.45s linear';
    // Insert overlay BEFORE the outlines group so outlines remain visible on top
    const outlinesG = svgRoot.querySelector('#__outlines_group');
    if(outlinesG) svgRoot.insertBefore(overlay, outlinesG);
    else svgRoot.appendChild(overlay);
    // force reflow
    void overlay.getBoundingClientRect();
    // start animation
    requestAnimationFrame(()=> {
      overlay.style.strokeDashoffset = '0';
    });
    // on finish
    const handler = function(ev){
      // some browsers report propertyName 'stroke-dashoffset'
      if(ev && ev.propertyName && ev.propertyName !== 'stroke-dashoffset' && ev.propertyName !== 'strokeDashoffset') return;
      overlay.removeEventListener('transitionend', handler);
      // remove overlay
      overlay.remove();
      // reveal the original segment (fill only)
      seg.classList.add('revealed');
      if(typeof onDone === 'function') onDone();
    };
    overlay.addEventListener('transitionend', handler);
    // safety fallback: if no transitionend fires, ensure reveal after 600ms
    setTimeout(()=> {
      if(svgRoot.contains(overlay)) {
        try{ overlay.remove(); }catch(e){}
        seg.classList.add('revealed');
        if(typeof onDone === 'function') onDone();
      }
    }, 900);
  } catch(e){
    // fallback
    seg.classList.add('revealed');
    if(typeof onDone === 'function') onDone();
  }
}

// modal handlers
modalCancel.addEventListener('click', ()=>{ modalEl.style.display='none'; modalEl.dataset.target=''; });

modalConfirm.addEventListener('click', ()=>{
  const name = modalEl.dataset.target;
  if(!name) return modalEl.style.display='none';
  const seg = segments.find(s => (s.getAttribute('data-name') || s.getAttribute('id')) === name);
  if(!seg){ modalEl.style.display='none'; return; }

  // Special-case: الفاتحة — تسجل محفوظة بدون تلوين (تجنُب لأن الفاتحة قد تمثل مساراً يغطي القلب كله)
  if(name === 'الفاتحة'){
    saved[name] = true;
    saved._last = name;
    localStorage.setItem('quran_heart_progress', JSON.stringify(saved));
    updateUI();
    encourage.textContent = `سورة الفاتحة تم تسجيلها (غير ملونة لتجنب تغطية القلب).`;
    modalEl.style.display = 'none';
    return;
  }

  try{
    // animate overlay draw then reveal
    animateDrawThenReveal(seg, name, () => {
      // after animation, save progress
      saved[name] = true;
      saved._last = name;
      localStorage.setItem('quran_heart_progress', JSON.stringify(saved));
      updateUI();
      // update corresponding label color
      const svgRoot = heartWrap.querySelector('svg');
      if(svgRoot){
        const labelsG = svgRoot.querySelector('#__labels_group');
        if(labelsG){
          for(let i=0;i<labelsG.children.length;i++){
            const lab = labelsG.children[i];
            if(lab && (lab.textContent || '').trim() === name) lab.classList.add('revealed');
          }
        }
      }
      encourage.textContent = `ما شاء الله! تم حفظ "${name}". استمر 🌟`;
      modalEl.style.display = 'none';
    });
  } catch(e){
    // fallback if anything fails
    seg.classList.add('revealed');
    saved[name] = true;
    saved._last = name;
    localStorage.setItem('quran_heart_progress', JSON.stringify(saved));
    updateUI();
    encourage.textContent = `ما شاء الله! تم حفظ "${name}". استمر 🌟`;
    modalEl.style.display = 'none';
  }
});

// reset
btnReset.addEventListener('click', ()=>{
  const ok = confirm('هل تريد إعادة التقدم من البداية؟ سيتم حذف التقدم المخزن على جهازك.');
  if(!ok) return;
  localStorage.removeItem('quran_heart_progress');
  saved = {};
  segments.forEach(s => s.classList.remove('revealed'));
  // remove label reveals
  const svgRoot = heartWrap.querySelector('svg');
  if(svgRoot){
    const labelsG = svgRoot.querySelector('#__labels_group');
    if(labelsG) for(let i=0;i<labelsG.children.length;i++) labelsG.children[i].classList.remove('revealed');
  }
  updateUI();
  encourage.textContent = 'تمت إعادة كل شيء — بالتوفيق في البدء من جديد 🌱';
});

// list saved
btnList.addEventListener('click', ()=>{
  const done = Object.keys(saved).filter(k=>k!=='_last');
  if(done.length === 0) return alert('لم تحفظ أي سورة بعد.');
  alert(`السور المحفوظة (${done.length}):\n` + done.join(', '));
});

// start
loadAndInjectSVG();
</script>
</body>
</html>
